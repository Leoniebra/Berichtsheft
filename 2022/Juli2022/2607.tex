\subsection{26. Juli}
Heute habe ich einen Schnitt in meiner Arbeit and Kibana und Elasticsearch gemacht. Ich hatte das Gefühl mich in der Arbeit mit der Grafikgrammatik Vega tiefer in die Erstellung von Diagrammen zu verrennen als möglich war, und habe das Gefühl einen guten Einblick in die Funktionalitäten und Bedienung von Kibana erhalten zu haben. Da meine Zeit in der Infrastrukturabteilung sich dem Ende zuneigt, habe ich mich in ein weiteres Thema eingelesen, bei dessen Erlernen ich hier gerne Hilfe bekommen möchte: Docker, und Containerisierung. Mithilfe eines Videotutorials habe ich die Verwendung von Docker zum Erstellen von Images, Containern und Containernetworks auf WSL2 (also einer virtuellen Maschine die Linux Ubuntu in Windows betreibt) gelernt. Das Video hat weiter anhand eines Beispiels gezeigt, wie eine Anwendung mithilfe von Docker einfach deployed werden kann, und wie dependencies in Container ausgelagert werden können um den Entwicklungsprozess zu beschleunigen. Ich habe mich mit der Erstellung von docker-compose.yaml files, sowie der Erstellung von Dockerfiles, sowie dem Schichtensystem von Docker auseinandergesetzt. Weiter habe ich meinen Kollegen um Hilfe beim Lernen von Virtualisierung und Containerisierung gebeten. Nach einem kurzen Einschub in welchem er mir die Funktionsweise und Bedienung des session-share Agenten tmux erklärt hatte, haben wir uns ausführlich über den strukturellen Aufbau, und die Unterschiede zwischen, Virtualisierungen und Containerisierungen unterhalten. Wir haben die Funktionsweise von Hypervisorn als Hartwarevirtualisierungen besprochen, sowie deren Vorteil als koordinatives Element zu allokation von Hardwareleistung. Weiter hat er mir den Unterschied zu Container, die nicht als zweiter Kernel, sondern stattdessen als sub-namespace im Kernel agieren erklärt. Ich habe als Übung hierzu ein Ubuntu System in einem Docker Container deployed, und konnte mithilfe des Prozessmanagers sehen, dass das im subnamespace laufende Ubuntu zwar die gesamte Hardware des Systems sowie dessen Nutzung beobachten kann, jedoch nur auf die Containereigenen Prozesse zugriff hat. Weiter habe ich als Test eine MySQL instanz in einem Container deployed, was gerade im Vergleich zu bisherigen Deploys die ich mit Apache durchgeführt hatte geradezu lächerlich einfach gewesen ist.
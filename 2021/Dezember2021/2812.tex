\subsection{28. Dezember}
ich habe mich heute mit der Umsetzung von Clean-Code-Conventions auf Basis des Konzepts der \textit{Object-Calisthenics} aus Jeff Bay's gleichnamigem Aufsatz befasst. Diese Konzept ist eine Zusammenstellung aus 9 Regeln, die lesbaren und einfach zu wartenden objektorientierten Code ermöglichen sollen. Die Regeln lauten wie folgt:
\begin{enumerate}
    \item \textbf{Nutze höchstens eine Einrückungsebene}. Code der aus verschachtelten Schleifen und Konditionalstatements besteht ist schwer zu lesen. Das Auslagern von Logik in eigene Methoden kann Abhilfe schaffen.
    \item \textbf{Vermeide das else-Schlüsselwort}. Verschachtelte if-else-Abfragen sind schwer zu lesen und verschleiern den eigentlichen Zweck der Methode. Abhilfe kann durch frühe returns innerhalb von if-statements, oder die Nutzung von Polymorphismen, z.B. durch Überladung von Methoden geschaffen werden.
    \item \textbf{Benutze Einbettungen für alle primitiven Typen.} Primitive Typen ohne Einbettung erlauben Fehlzuweisungen. Wenn wir einen Parameter "Stunden" übergeben wollen, empfiehlt es sich, eine Klasse Stunden mit einer privaten int-Variable zu übergeben. Auf dieses Feld greifen wir durch die Methoden der Klasse (siehe Punkt 9) zu.
    \item \textbf{Verwende in jeder Zeile nur einen Punkt.} Lange Statements der Form \\ \texttt{Class1.Class2.Class3.Method()} verletzen das Prinzip der Kapselung von Informationen. Informationen sollen nur lokal weitergereicht werden, am besten durch eine Methode der besitzenden Klasse. Dies folgt \textsc{Demeters Gesetz}: \textit{Sprich nur mit deinen Freund:innen.}
    \item \textbf{Gebrauche keine Abkürzungen.} Methoden- und Klassennamen sollen aussagekräftig sein, und einen ersten - und im Idealfall auch einzigen - Beitrag zu einer nachvollziehbaren und Aussagekräftigen Programmdokumentation leisten. Abkürzungen sollten nach Möglichkeit nur verwendet werden, wenn mit verlässlicher Sicherheit von deren allgemeinen Bekanntheit ausgegangen werden kann - OOP für \textbf{O}bjekt\textbf{O}rientierte \textbf{P}rogrammierung ist vermutlich okay. MPA für \textbf{M}ein \textbf{P}ersönliches \textbf{A}kronym dagegen nicht.
    \item \textbf{Halte alle Dinge klein.} Klassen und Methoden sollen \textit{kurz} sein. Klassen sollen eine Länge von 50 Zeilen, Methoden eine Länge von 10 Zeilen nicht überschreiten - sind sie länger, so ist es wahrscheinlich dass sie mehr als eine Sache tun - was den Grundprinzipien dieses Ansatzes widerspricht.
    \item \textbf{Weise Klassen nicht mehr als zwei Instanzvariablen zu.} Klassen sollen nur eine Sache tun. Spalte Klassen, um sie von einer Menge an Attributen in eine Hierarchie kollaborierender Objekte zu verwandeln.
    \item \textbf{Sammlungen verdienen eigene Klassen.} Enthält eine Klasse eine Sammlung (also eine Liste, ein IEnumerable oder Ähnliches) - dann sollte sie keine anderen Mitglieder enthalten. Dagegen sollte aber die Logik mit der diese Sammlung gefiltert wird in dieser Klasse leben.
    \item \textbf{Verbanne Setter, Getter und Eigenschaften aus deinem Code.} Öffentliche Get- und Set- funktionen sind ein Antimuster der objektorientierten Programmierung und verletzen das Prinzip der Kapselung von Information. Wird eine Information von außen benötigt, dann soll sie durch explizite Angabe einer Methode bereitgestellt werden. \textit{Tell, do not ask.}
\end{enumerate}

